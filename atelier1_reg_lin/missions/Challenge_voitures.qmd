---
title: "Challenge ‚Äî Prix de voitures"
format: html
execute: 
  echo: true
  eval: false

---

> **Dataset** : *Used Car Dataset* ‚Äî Kaggle (auteur: **rishabhkarn**).  
> Lien : https://www.kaggle.com/datasets/rishabhkarn/used-car-dataset  
> ‚ö†Ô∏è **V√©rifiez la description Kaggle pour les **noms exacts** de colonnes** (ils peuvent varier selon la version).  
> Noms courants : `selling_price` (r√©ponse), `year`, `km_driven`, `fuel`, `transmission`, `seller_type`, `owner`, `name`.

## üéØ Objectif
Construire un **mod√®le de r√©gression lin√©aire multiple** `lm()` pour expliquer le **prix** d‚Äôune voiture d‚Äôoccasion et **interpr√©ter au moins un effet majeur**.

---

```{r setup}

```


## 0) Pr√©paration
```{r}
# Packages utiles
library(dplyr); library(ggplot2); library(readr); library(janitor); library(broom)
# (Optionnel) diagnostics
# library(car); library(performance)

# ‚ö†Ô∏è Adaptez le chemin vers votre CSV Kaggle
# Exemple : data/used_cars.csv
# cars_raw <- read_csv("data/used_cars.csv")

# Pour la d√©monstration, on cr√©e un tibble vide si vous n'avez pas encore le fichier.
# Supprimez ce bloc une fois votre CSV charg√©.
cars_raw <- tibble::tibble()
```

::: {.callout-warning}
**Important ‚Äî Noms de colonnes**  
Les champs les plus fr√©quents sont :  
`selling_price`, `year`, `km_driven`, `fuel`, `transmission`, `seller_type`, `owner`, `name`.  
**Ouvrez le CSV** et **confirmez les noms** via `names(cars_raw)` ou `glimpse(cars_raw)`.
:::

```{r}
# V√©rifier les colonnes disponibles
# glimpse(cars_raw)
```

---

## 1) Nettoyage minimal
```{r}
cars <- cars_raw %>%
  janitor::clean_names()

# Exemple de normalisation (adaptez aux noms r√©els de votre fichier)
# - Si votre fichier contient bien "selling_price", "km_driven", etc., ces lignes sont OK.
# - Sinon, renommez selon la description Kaggle.
cars <- cars %>%
  dplyr::rename(
    price = selling_price,       # <‚Äî renommer la variable r√©ponse
    mileage_km = km_driven       # <‚Äî renommer le kilom√©trage
  )

# Encodage des cat√©gorielles (adaptez selon vos colonnes exactes)
cars <- cars %>%
  mutate(
    fuel = as.factor(fuel),
    transmission = as.factor(transmission),
    seller_type = as.factor(seller_type),
    owner = as.factor(owner)
  )

# Gestion simple des valeurs manquantes (√† raffiner si besoin)
cars_complete <- cars %>% tidyr::drop_na(price, year, mileage_km, fuel, transmission)
```

::: {.callout-note}
**√Ä faire (√©quipe)**  
- Confirmer que `price` est bien la **r√©ponse** (sinon, adaptez).  
- V√©rifier l‚Äôunit√© de `mileage_km` (km).  
- Choisir une **r√©f√©rence** pertinente pour `fuel` et `transmission` (ex. essence, manuelle).
:::

---

## 2) EDA rapide
```{r}
# Distribution du prix (attention aux queues)
ggplot(cars_complete, aes(price)) + geom_histogram(bins=30, alpha=.7) +
  scale_x_continuous(labels = scales::label_number_si()) +
  labs(title="Distribution des prix")

# Prix vs kilom√©trage (possible non-lin√©arit√©)
ggplot(cars_complete, aes(mileage_km, price)) + geom_point(alpha=.3) +
  scale_y_continuous(labels = scales::label_number_si()) +
  scale_x_continuous(labels = scales::label_number_si()) +
  labs(title="Prix en fonction du kilom√©trage")

# Prix par transmission
ggplot(cars_complete, aes(transmission, price)) + geom_boxplot() +
  scale_y_continuous(labels = scales::label_number_si()) +
  labs(title="Prix par type de transmission")
```

::: {.callout-tip}
**Piste** : tester des **transformations** si la relation prix ~ kilom√©trage semble non lin√©aire (ex. `log(price)`, `log1p(mileage_km)`).  
:::

---

## 3) Mod√®le de base (‚â§ 6 pr√©dicteurs)
```{r}
mod0 <- lm(price ~ year + mileage_km + fuel + transmission + seller_type, data = cars_complete)
summary(mod0)
```

::: {.callout-note}
**Questions**  
- Quel pr√©dicteur a l‚Äô**effet le plus fort** (en valeur absolue) ?  
- Interpr√©tez l‚Äôeffet de `transmission` (manuelle vs auto) **toutes choses √©gales par ailleurs**.  
:::
  
---

## 4) Variante avec transformation
```{r}
mod1 <- lm(log(price) ~ year + log1p(mileage_km) + fuel + transmission + seller_type, data = cars_complete)
broom::glance(mod0)[,c("r.squared","AIC","BIC")]
broom::glance(mod1)[,c("r.squared","AIC","BIC")]
broom::tidy(mod1) %>% head()
```

::: {.callout-tip}
**Interpr√©tation** (log-prix)  
- Un coefficient sur `year` ‚âà **variation en %** de prix par ann√©e suppl√©mentaire (petite pente).  
- `log1p(mileage_km)` : √©lasticit√© approximative au kilom√©trage.  
:::

---

## 5) (Option) Diagnostics rapides
```{r}
par(mfrow=c(2,2)); plot(mod1); par(mfrow=c(1,1))
# car::vif(mod1)
```

::: {.callout-warning}
**Attention**  
- Colin√©arit√© possible entre `year` et `owner` (ou d'autres variables).  
- Valeurs extr√™mes (prix/vehicules premium) pouvant influencer fortement les coefficients.  
:::
  
---

## 6) Restitution (√©quipe)
1. **Expliquez un effet majeur** (ex. transmission, fuel, year) avec une phrase claire pour un public non technique.  
2. **Comparez** `mod0` vs `mod1` (AIC/BIC, R¬≤) ‚Üí quel mod√®le retenez-vous, et pourquoi ?  
3. **Limites** : mentionnez au moins une limite de votre mod√®le (donn√©es, hypoth√®ses, variables manquantes).

---

## ‚≠ê Bonus
1. Ajoutez `interaction(year:transmission)` si vous suspectez un effet diff√©rent selon la transmission.  
2. Cherchez un **point influent** (distance de Cook) et discutez s‚Äôil faut l‚Äôexclure.  
3. Proposez une **variable m√©tier** √† ajouter (ex. historique d‚Äôentretien, accidents, options).
